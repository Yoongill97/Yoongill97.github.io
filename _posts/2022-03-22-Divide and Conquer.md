---
layout: single
title: 분할정복 (Divide and Conquer)
---
#분할정복 알고리즘?

정의 : 분할정복 알고리즘은 문제를 나눌 수 없을 때까지 나누어서 각각을 풀고,
다시 병합하여 문제의 답을 얻는 알고리즘이다.

##요령

분할 정복에 관련된 문제라고 생각할 경우, 다음 세개의 큰 틀로 진행하는 것이 좋다.
1. Divide : 문제가 분할이 가능할 경우, 분할한다.
2. Conquer : 여전히 다시 분할이 가능할 경우, 계속 분할한다.
3. Combine : 2번 단계에서 나온 문제들을 통합하여 답을 얻는다.

#병합 정렬 (Merge Sort)

병합 정렬은 분할정복의 대표적인 예로, 분할정복의 실행과정이 직관적으로 보여진다.

##알고리즘

1. 데이터의 크기가 0 또는 1이면 이미 정렬된 것으로 본다.
2. 정렬되지 않은 데이터를 절반으로 분할한다. (Divide)
3. 2번이 가능하지 않을 때까지 분할한다. (Conquer)
4. 각 데이터들을 정렬하여 합병한다. (Combine)

##Code

![mergesort](/assets/images/merge_sort.png)
위에서 말한 1~4번의 과정들이 담겨있다.
if(start < end) 조건에서 데이터집합을 절반으로 분할할 수 있는지 판별하고,
가능하다면 middle, 즉 중간을 기준으로 데이터집합을 둘로 분할한다.
이 과정에서 재귀호출을 통해 if문의 조건이 부합하지 않을 때까지 데이터집합을 분할한다.
분할이 끝나면 merge함수를 통해 각 데이터들을 정렬하고 합병한다.

![merge](/assets/images/merge_merge.png)
헷갈리지만 while문의 조건과 mergesort의 재귀호출에 대해 조금만 생각해보면 굉장히 쉽다.
정렬을 한 후, 병합하고 이 결과물들을 다시 정렬하여 병합한다.
예를 들어, {1, 8, 5, 3, 2, 9, 1, 7,}이라는 데이터 집합이 있다고 가정해보자.
모두 분할을 마친 후에는 첫 병합에서 1과 8이 정렬 후 병합되어 {1, 8},
5와 3이 정렬 후 병합되어 {3, 5}이라는 작은 결과물이 생긴다. (나머지 생략)
여기서 다시 {1, 8} 과 {3, 5} 을 정렬하고 병합한다.
1과 3을 비교해서 {1}, 8과 3을 비교하여 {1, 3}, 8과 5를 비교하여 {1, 3, 5}가 되고,
if문의 조건에 따라서 나머지값이 들어가 {1, 3, 5, 8}라는 조금 더 큰 결과물이 생긴다.
나머지 2, 9, 1, 7도 같은 과정으로 {1, 2, 7, 9}라는 데이터 집합으로 병합되고,
다시 {1, 3, 5, 8}과 {1, 2, 7, 9}를 정렬하고 병합하면 최종 결과물이 나오게 된다.

![main](/assets/images/merge_main.png)
임의의 숫자를 넣고 정렬해보았다.
![result](/assets/images/result.png)
정상적으로 정렬이 되는 모습을 볼 수 있다.

##기타등등

병합정렬은 굉장히 안정적이다. 대표적으로 퀵 정렬은 기준값인 pivot의 설정에 따라서 실행시간이 달라진다.
이에 비해 병합정렬은 입력 데이터가 무엇이든 간에 정렬시간이 O(NlogN)으로 동일하다.
하지만 작은 단위로 쪼갠 데이터를 저장할 공간을 필요로 하기때문에 추가적인 메모리가 필요하다는 점이 단점이다.